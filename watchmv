#!/usr/local/bin/node

//config
var log = console.log.bind(console);
var mkdirp = require('mkdirp');
var fs = require('fs-extra');
var cho = require('chokidar');
var mime = require('mime');
var path = require('path');
var args = require('minimist')(process.argv.slice(2));
var params = args._;
var queue = require('queue');
var execSync = require("exec-sync");
var mv = require('mv');

//resolve args
if(args['h']){
	log('Usage: watchmv [options]... [preset] [PATH SRC] [PATH DEST]');
	log('\n')
	log('# Auto-import music files:\n > watchmv itunes [PATH SRC] [PATH to itunes music library]');
	log('# Restrict by mimetypes or extenstions:\n > watchmv --allow-mime-types=audio/mpeg,video/mp4 --allow-extensions=mp3,jpg,gif,mp4 [PATH SRC] [PATH DEST]');
	process.exit(code=0);
}

if(params.length<2){
	log('Usage: watchmv [options]... [preset] [PATH SRC] [PATH DEST]');
	process.exit(1);
}


var dir_target = params.length==3 ? params[1] :params[0];
var dir_to = params.slice(-1)[0];

//init presets
var preset = params.length==3 ? params[0] : 'notdefined';
var preset_values = ({
	itunes : {
		// itunes supported types : mp3, aiff, wav, mp4, aac, m4a
		ext:['.mp3', '.aiff', '.wav', '.mp4', '.aac', '.m4a'],
		mime:['audio/aac', 'audio/mp4', 'audio/mpeg', 'audio/mp4a-latm', 'audio/x-wav', 'audio/x-aiff']
	}
})[preset];

//resolve mimetype, extension
var option_exts = args['allow-extensions'];
var option_mimes = args['allow-mime-types'];
var exts_by_option = option_exts && option_exts.split(',');
var exts_by_preset = preset_values && preset_values.ext;
var allowed_exts = exts_by_option && exts_by_preset ? exts_by_option.concat(exts_by_preset) : (exts_by_option || exts_by_preset);

var mimes_by_option = option_mimes && option_mimes.split(',');
var mimes_by_preset = preset_values && preset_values.mime;
var allowed_mimes = mimes_by_option && mimes_by_preset ? mimes_by_option.concat(mimes_by_preset) : (mimes_by_option || mimes_by_preset);

//init lists
var files_hash = {};
var files_roots = {};

//queue config
var q = queue({timeout:3000, concurrency:true});
var wait_removal = 10 * 1000;

//watch
var watcher = cho.watch(dir_target, {
  persistent: true,
  recursive: true,
  ignoreInitial: true,
  usePolling: true,
  alwaysStat: false,
  depth: undefined,
  interval: 0,
  atomic: true
});

watcher.on('all', function(e,f) {

    var ext = path.extname(f);
	var valid_ext = allowed_exts ? allowed_exts.indexOf(ext.toLowerCase()) > -1 : true;

	var mt = mime.lookup(f);
	var valid_mime = allowed_mimes ? allowed_mimes.indexOf(mt) > -1 : true;

	var valid_format = valid_ext && valid_mime;

    var temp_origin_f = path.join(path.dirname(f), path.basename(f).replace(path.extname(f), ''));
    var temp_streaming = 'application/octet-stream'==mt && allowed_exts.indexOf(path.extname(temp_origin_f))>-1;

    var copied = valid_format && files_hash[f]=='add' && e=='change';
    //FIXME: dont't work when stream handled during temp writing.
    var stream_completed = valid_format && files_hash[f]=='stream_add' && e=='add';

    //start job
    if(copied || stream_completed){
        log('deploy start', f);

        // watcher.unwatch(f);
        setTimeout(function(){
            delete files_hash[f];
            add_job_move_f(f, get_dest_f(f, dir_to));
        }, stream_completed ? 1000 : 0);
    }

    if(e=='add'){
        files_hash[temp_streaming ? temp_origin_f : f] = temp_streaming ? "stream_add" : "add";
    }
});

//queue
q.on('success', function(result, job) {

});

function add_job_move_f(target_f, dest_f) {
    var __op = function (cb) {
        move_f(target_f, dest_f);
        cb();
    };

    if (q.length == 0) {
        q.push(__op);
        q.start(function(err) {

            flush_jobs_all();
        });
    }else{
        q.push(__op);
    }
}

function flush_jobs_all(){
    Object.keys(files_hash).forEach(function( k ){
        var target_f = k;
        delete files_hash[k];
        move_f(target_f, get_dest_f(target_f, dir_to) );
    });
}

function move_f(target_f, dest_f) {
    try{
        fs.copySync(target_f, dest_f);

        wait_remove_all(target_f);
    }catch(e){
        log(e);
    }
}

function wait_remove_all(target_f){
    var target_f_root = get_target_root(target_f);

    var timeoutObj = files_roots[target_f_root];
    timeoutObj && clearTimeout(timeoutObj);
    timeoutObj = setTimeout(function(){
        delete files_roots[target_f_root];
        fs.remove(target_f_root, function(e){
            log('Done.', target_f_root);
        });
    }, wait_removal);
    files_roots[target_f_root] = timeoutObj;
}

function get_dest_f(f, dest_dir){
    dest_dir = path.join(dest_dir, path.basename(get_target_root(f)));
    return path.join(path.join(dest_dir, path.basename(path.dirname( f ))) , path.basename( f ));
}

function get_target_root(f){
    return path.join(dir_target, path.resolve(f).replace(path.resolve(dir_target),'').split(path.sep)[1]);
}

log('Start watching...',dir_target, '->', dir_to);
